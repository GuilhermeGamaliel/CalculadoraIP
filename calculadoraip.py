# -*- coding: utf-8 -*-
"""CalculadoraIP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_k2rR_KaezpjUVop3aTSyO3l4b8G7P-d
"""
import math

# Entrada de dados por parte do usuário
ip = input(str("Coloque o IP: "))
mascara = input(str("Coloque a mascara que deseja aplicar no ip: "))
numero_func = input(str("Selecione a primeira ou a segunda função: "))

# Caso o usuário coloque um IP inválido

# Abaixo temos a trecho que separa o ip e ao mesmo tempo o
# Modulo de correção de dados
mascara = mascara.replace("/", "")
ip_dividido = ip.split(".")
number = ip.replace(".", "")
mask = mascara
func = numero_func

# Modulo de verifição de digito:
# Caso alguma das variaveis seja uma palavra qualquer,
# será pedido ao usuário que mesmo informe a variavel novamente
while number.isdigit() == False:
  print("")
  print("Por favor insira um ip válido")
  ip = input(str("Coloque o IP: "))
  number = ip
  number = number.replace(".", "")
  if number.isdigit() == True:
    ip_dividido = ip.split(".")
    pass

while mask.isdigit() == False:
  print("")
  print("Por favor insira uma mascara válida")
  mascara = input(str("Coloque a mascara que deseja aplicar no ip: "))
  mask = mascara
  mascara = mascara.replace("/", "")
  if mask.isdigit() == True:
    pass

while func.isdigit() == False:
  print("")
  print("Por favor insira uma função válida")
  numero_func = input(str("Selecione a primeira ou a segunda função: "))
  func = numero_func
  if func.isdigit() == True:
    pass

# Modulo de verificação de ip
# Caso o ip informado possua um número incorreto de octetos ou
# Algum de seus octetos seja incorreto
while len(ip_dividido) != 4:
  print("")
  print("Por favor insira um ip válido")
  ip = input(str("Coloque o IP: "))
  ip_dividido = ip
  ip_dividido = ip.split(".")

for i in ip_dividido:
  while int(i) > 256 or int(i) < 0:
    print("")
    print("Por favor insira um ip válido")
    ip = input(str("Coloque o IP: "))
    ip_dividido = ip.split(".")

# Modulo de verificação de mascara
# Caso a mascara seja inadequada 
# Ela terá de ser substituida por um correta

if int(mascara) < 25 or int(mascara) > 32:
  print("")
  print("Essa mascara não existe, tente uma mascara dentro de /25 a /32")
  mascara = input(str("Coloque a mascara que deseja aplicar no ip: "))

# Modulo de verificação de função
# Caso o usuario escolha um função inadequada
# Ele terá que informala novamente
elif numero_func != "1" and numero_func != "2":
  print("")
  print("Essa função não existe, " +
  "para primeira função digite 1, " +
  "para segunda função digite 2")
  numero_func = input(str("Selecione a primeira ou a segunda função: ")) 

# Declaração de variáveis 
# Variaveis Estéticas
principal = ip_dividido[0] + "." +  ip_dividido[1] +  "." + ip_dividido[2] + "."
last = int(ip_dividido[3])

# Variaveis Essencias

host = 0
primeiro_ip = host + 1
divisor_total = 2 ** (int(mascara) - 24)
broadcast = int(256 / divisor_total) - 1
ultimo_ip = int(broadcast) - 1


# Primeira função que traz a tabela contendo todas as subredes
def primeira_func(ip, mascara, host, primeiro_ip, ultimo_ip, broadcast):
  print("")
  print("   Host    | Primeira IP disponivel " +
        "| Último IP disponivel | Broadcast")
  for i in range(divisor_total):
      print(principal + str(host) + " |" + "     " 
            + principal + str(primeiro_ip) + "     |"
            + "     " + principal + str(ultimo_ip) + "     |"
            + "     " + principal + str(broadcast))
      host = host + int(256 / divisor_total)
      primeiro_ip = host + 1
      broadcast = host + int(256 / divisor_total) - 1
      ultimo_ip = broadcast - 1
# Basicamente esta primeira função cria a tabela baseado em calculo:
# A diferença entre a mascara informada e 24 elevado a dois.
# Esse calculo gera um divisor que eu uso para dividir o número 256,
# Assim aumentando gradativamente linha por linha o host e o broadcast.


# Segunda função que busca a subrede especifica onde o ip está localizado

def segunda_func(ip, mascara, host, primeiro_ip, ultimo_ip, broadcast):
  print("")
  print("   Host    | Primeira IP disponivel " +
        "| Último IP disponivel | Broadcast")
  for i in range(divisor_total):
    if host <= last and broadcast >= last:
      print(principal + str(host) + " |"
        + "     " + principal + str(primeiro_ip) + "     |"
        + "     " + principal + str(ultimo_ip) + "     |"
        + "     " + principal + str(broadcast))
      host = host + int(256 / divisor_total)
      broadcast = host + int(256 / divisor_total) - 1
    else:
      host = host + int(256 / divisor_total)
      primeiro_ip = host + 1
      broadcast = host + int(256 / divisor_total) - 1
      ultimo_ip = broadcast - 1
# Funciona de maneira semelhante a função anterior,
# Porém aqui a tabela só é construída quando convém
# No caso quando é a subrede especifica que estamos procurando


# Bloco de decisão que chama a primeira ou a segunda função
# Dependendo do que o usuario quiser

if numero_func == "1":
  primeira_func(ip, mascara, host, primeiro_ip, ultimo_ip, broadcast)
elif numero_func == "2" :
  segunda_func(ip, mascara, host, primeiro_ip, ultimo_ip, broadcast)